Объяснение кода 
-

Класс TabuSearchScheduling инициализирует параметры задачи

Метод initializeSchedule() создает начальное решение, случайным образом распределяя рабочие дни для каждого сотрудника. Это гарантирует разнообразие начальных условий для алгоритма поиска.

Функция оценки evaluateSolution() вычисляет стоимость текущего расписания

Она добавляет штрафы за отклонения от требуемого количества рабочих дней и нарушения ограничения на последовательные выходные.

Генерация соседних решений выполняется в generateNeighbors()

neighbor[i][j] = 1 - neighbor[i][j];
int temp = swapNeighbor[i][j];

Алгоритм создает новых кандидатов путем инверсии статуса дня (рабочий/выходной) или обмена дней между разными работниками.

Основной цикл табу-поиска в методе tabuSearch()

neighbors.sort(Comparator.comparingInt(n -> n.cost));
tabuList.add(bestNeighbor.move);

На каждой итерации выбирается лучшее допустимое соседнее решение, которое добавляется в табу-лист для предотвращения циклов.

Класс TabuList управляет историей движений

Он ограничивает размер очереди, удаляя старые записи и проверяя наличие запрещенных движений.

Объяснение алгоритма
-
Алгоритм табу-поиска для планирования:

Создаем случайное начальное расписание

Оцениваем качество - штрафуем нарушения ограничений

Генерируем соседние решения - меняем дни работников

Выбираем лучшее разрешенное решение (не в табу-листе)

Добавляем движение в табу-лист - предотвращаем циклы

Повторяем пока не найдем оптимальное решение или не закончатся итерации








Результаты выводятся через printSchedule() и checkConstraints(), которые показывают финальное расписание и проверяют выполнение всех бизнес-правил задачи планирования.
